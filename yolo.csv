id,content,documentId,documentTitle
9_5924718406270976_5361768452849664,"The scenarioYou receive an email from a long-forgotten client. They want you to undertake a Python project for them. To complete it, they have sent you all the project details you require via email. Here’s what you know about your role and the project’s requirements.Your roleYou are being hired as a Python software engineer. You are required to understand the project requirements and translate them into Python code. On successful delivery of the project, you will be considerably compensated.Project descriptionYour client wants an app that will be used by students in a network of elementary schools. As the end-users of your app, these elementary school students will be able to exercise their basic maths skills. The app will pose random maths questions to the students and check if they have entered the correct answers. The client intends to improve their students’ math competency through the app.Project requirementsThe client has also specified the app’s exact functional requirements. They are as follows:With the list of these basic requirements, you can understand how the app will work better now. What the project will look like to its usersFor a clearer picture of the project, your client has sent you the following interface as well. To get started, type your name in the window below and press “Enter.” Follow the remaining instructions to see the complete app in action. This will help you understand exactly what kind of app your client wants you to develop for them.Learn to code in Python However, you’re in a dilemma. On the one hand, you have absolute clarity now on what the project requires, but on the other, the only thing between you and the project’s delivery is the fact that you do not know how to code in Python!! That is where this course comes to your rescue. If you are up for it, let’s learn how to code in Python. Project-based learning This course not only helps you deliver the project to the client on time, but it also teaches you Python along the way. Isn’t that incredible?You have decided to accept the client’s offer based on what this course promises. What a wonderful addition to your portfolio this Python project will be!",5361768452849664,You are Hired for a Python Project
9_5924718406270976_6487668359692288,"What is a computer program made of? There is a basic structural and foundational unit of everything that exists. The basic unit of matter is an atom. The basic unit of living beings is a cell. As far as this course is concerned, the foundational unit of a computer program is known as a function . As its name implies, each function is designed to execute a specific and crucial task, providing a modular and organized approach to constructing and maintaining code. As we delve into this course, understanding the significance of functions will be key to mastering the art of procedural programming in Python. A function has three components: input, processing, and output. Function as a black box Input : The data that the function has to work on. Processing : Steps and operations necessary to achieve the function’s objectives. Output : The result or the information that the function computes after processing the input. Using functions Python provides its users with built-in functions that carry out some useful tasks. The processing part of built-in functions is hidden from us, as Python takes care of that on our behalf. We are only concerned with what we feed them as input and what they give us as the output. Let’s take Python’s built-in function round as an example. It takes in a fractional value (e.g. 3.1415) and rounds it off to the nearest whole number. The widget below helps us visualize how this function works. Provide it with an input and observe the output it produces when you press the round() button. The round() function round() is the type of function that must take a single input, but some functions may require multiple inputs or no inputs at all. An example of a function that takes two inputs is the pow() function that calculates the power of a number. The two inputs are the base and the exponent, and it returns the result of raising the base to the power of the exponent, e.g., 1 0 2 = 100 10^2=100 1 0 2 = 100 . The pow() function Let’s get our hands dirty with Python To use any function in Python, we must make a call to it. This can be done by writing the name of the function, followed by a set of opening “ ( ” and a closing parentheses “ ) ” . Inside the parentheses, we can provide the inputs to the function. Press the “Run” button. 1round(3.14159)RunSaveResetRounding a number using the round() functionCongratulations , you just executed your first Python code successfully!To give multiple inputs to a function in Python, the values must be separated by commas. The code below shows how it’s done for pow() . 1pow(2, 3)RunSaveResetTaking power of a number using the pow() function The order in which we provide the inputs is important. In this example, the first input is automatically considered as the base, while the second input is considered as the exponent. What’s next? We pressed the “Run” button, and it executed our code successfully in both cases, but it did not show us any output that we were expecting to see. Since no error was encountered, we managed to make the computer work for us. But how do we verify if they are doing what we expected them to do? Is there a way for us to see their output?",6487668359692288,Function of a Python Program
9_5924718406270976_4658081011073024,"The built-in print() function Let’s start building the project using built-in functions. We have already seen some built-in functions, and we know that a function does the following things:It takes something as its input.It processes this input to create some output.It returns the output.The most prominent Python built-in function that prints something on the screen is print . It prints anything we give as input on the screen. For instance, guess the result of the following code when you press the “Run” button?1print(3.1415)RunSaveResetPrinting a numberIt simply prints the exact number you gave as input to the print function. This function gives us the power, as a programmer, to verify what the computer has done for us. For example, we know what the built-in function round is supposed to do. It takes any number with a decimal point and rounds it to the nearest whole number, meaning 3.1415 should get rounded to 3. Try it yourself by pressing the “Run” button:1round(3.1415)RunSaveResetRounding a numberThere wasn’t any error, and the computer seems to have done its job, but we couldn’t really confirm if the round function worked as we expected. So, what happens if we use print and round together? We know by now that a method can take an input, do something with it, and return a processed output. The method named round() can take as input 3.1415 , process it to truncate the number to the nearest whole number, and then return the whole number 3 . Is there a way for us to take all of what round as a method does and give that as input to the print method? Study the code below carefully, and then run it to see the output:1print(round(3.1415))RunSaveResetPrinting the rounded numberThe project requires printing on the screen Let’s attend to our client’s requirements for the project, armed with our new Python knowledge. There are at least three major project requirements (2, 3, and 9), from the following, that will use our knowledge of the print() function. The project requirements that require printing on the screen Printing the score We’ll begin by attempting to print the user’s score on the screen (requirement 9). Let’s imagine the student has managed to score 4 marks. Can you print 4 on the screen so they can see it?1RunShow SolutionSaveResetWrite a Python code to print 4 on the screenTry it OutWe can even make the computer work for us and compute the correct answer to a sum-based question. Let’s say the student was asked to solve 2 + 8. Regardless of the answer, our computer should know the correct answer to this question (requirement 6).1print(2 + 8)RunSaveResetPrinting the sum of two numbersThis code does not print 2 + 8 2+8 2 + 8 on the screen, it prints 10. This means that the computer knows how to resolve the + operator, which is great. Printing a text message But sometimes, we don’t want the computer to compute or resolve anything, we simply want it to print whatever we give it to print. For example, for requirement 9, we need to print a message on the screen for the student because the computer needs to engage with users. Simply printing out a 4 on the screen at the end will not be the best practice. We need to be able to tell the user that this 4 was their actual score. Since we have already used the print() function to print a number, we will use the same function to print a text message as well. Click the “Run” button in the code widget below:1print(You have managed to score)RunSaveResetTrying to print a piece of textWell, that did not work as per our expectations. Can you think of any reason why print(4) worked like a charm but not print(You have managed to score) ? Perhaps we have confused Python’s print function with this text input.Remember what we normally do in our novels when we want to separate the dialogue from normal text. We put quotation marks around the dialogues within the text. We have to do the same here as well. The Python code we are writing is also text, e.g., print is a Python command but is written as text, and the input to the print function is also text, You have managed to score . We need to put double quotes around the text message before printing like so:1print(""You have managed to score"")RunSaveResetPrinting a piece of text successfullyTry it OutPython does not like it if you miss one quotation or a parenthesis. They come in pairs!Let’s try one little experiment while we are only trying to get to know how Python and programming work by trying out various things. Don’t be afraid of experimenting with your own ideas. What’s the worst that can happen? At most, your code won’t work, and Python will try to complain about it. We only care deeply about conceptual clarity at the moment : )Try running the following four Python programs one by one. But before clicking the “Run” button, try imagining what the output for each program should be:1print(""Your score is 10"")RunSaveResetExample 11print(""10"")RunSaveResetExample 21print(""2 + 8"")RunSaveResetExample 31print(2 + 8)RunSaveResetExample 4Python prints anything inside quotation marks verbatim (on an as-is where-is basis). That’s why 2 + 8 with quotation marks is printed as is, while 2 + 8 without quotation marks prints 10. Concatenating the text We know what the + operator does for numbers. We have seen that Python also knows the meaning of + . But here is where the similarity ends. Can you think of another way the same + can be used for two text messages? For example, what would be the result of:""You have managed"" + ""to score 10 marks""Of course, adding or summing up only makes sense for numbers.Try it in Python yourself in the widget below. Print the above to see what output we get:1RunShow SolutionSaveResetSo Python also lets us use + for two pieces of text as well—it joins the two pieces of text together. But if you look closely, it ate up the space between “managed” and “to,” and the student will be confused to read the word “managedto.” Sometimes, we need to rescue Python from the mistakes it makes. Here, to help Python, why don’t we try putting an extra space before closing the quotation marks around managed?Try it Out Take away: The meaning of + is slightly different for text. Python concatenates or joins the two pieces of text with + .Another lesson here is that there seem to be multiple ways of achieving results in Python, just as it is in life. Printing the text message and score together In one arrangement, we can see that Python even lets us use a comma-separated print function:1print(""You have managed"" , ""to score 10 marks"")RunSaveResetAn example of a comma-separated print functionWe know some functions can take two inputs, such as a power function. The same is the case with print. Python lets us give as many inputs (separated by commas) to the print function as we require. This comes in handy because we can ask it to print 2 things for us in a row, or however many we want. We can also ask it to print a text message as well as a number, separated by commas:1print(""First message"" , ""Second message"", 1, 2, 3, ""Third message"")RunSaveResetAnother example of a comma-separated print functionThis gives us the power to fulfill another project requirement. Let’s imagine that we want to tell the learner about what the correct answer to a question is, but we want the computer to work it out for us because we know it’s flawless in computing sums:12print(""The correct answer for 8 + 2 is:"", 8 + 2)print(""The correct answer for 816234 + 256423 is:"", 816234 + 256423)RunSaveResetPrinting the correct answerNice! So, Python lets us write more than one line of code, and executes it one by one! The next project requirement We’re doing pretty good so far. We have learned what it takes to output something on the screen. With the help of the print function, we have grown confident enough to understand our client’s requirements for the Python project. But let’s not jump ahead too quickly. In the next lesson, we’ll navigate the demands of requirements 1 and 5—that we take something as input from our app’s users. BackFunction of a Python Program",4658081011073024,Compute and Output
9_5924718406270976_5763090196987904,"Taking input from a user Let’s continue making our way into Python and the project. Notice that project requirements 1 and 5 are categorically different from requirement 2, which is printing something on the screen. The project requirements that require printing the output on the screen Now we know how to print a name on the screen using Python, but how does our code ask the elementary school student to tell us their name? The built-in input() function Just like print prints something on the screen, what would be the name of the built-in function that takes input from the user’s keyboard? You guessed it! Python offers us another built-in function with the name of input . Note: After clicking the “Run” button, click anywhere inside the black terminal window. When you see a blinking cursor, you will know that the program is waiting for your input. Use your keyboard to write anything and then press enter. Give it a shot: main.py1input()RunSaveResetTaking the input using the input() function Notice there’s only one line of code, and it says input() . You ran the code, and then, you typed in something. While you were typing, of course, you could see on the black command line, each letter that you pressed on the keyboard. But as soon as you hit the “Enter” button on the keyboard, the code stops executing as the Python program completes its run. It did what it was set out to do—it let the end-users use their keyboard to give it input. But this raises two important questions. Where has the user’s input gone, really? And secondly, in a real app, how does the user know what the app wants them to enter? How does the user know what they are required to input? From the end user’s perspective (in this case, a student), how are they supposed to know if they have to enter a name, a number, or anything else? Wouldn’t it be better if every time we want a user to input something, we could prompt them with an appropriate message or a question? Python lets us do this using the same input function. main.py1input(""Please tell us your name: "")RunSaveResetTaking input using the input() function with a message This is much better in terms of meaningful user interaction. This means, input() is a built-in function that can take an optional text message within its parentheses as well.It’s always a good idea to think about your code’s end user to make our apps more efficient for their use. Where has the user’s input gone? Now, the user knows what the code wants them to input, that’s one issue out of the way. But what about the input from the user? We need to be able to welcome, by name, any student who is using our app. Can we use the print() function in tandem with our newly learned input() function? main.py1print(input(""Please tell us your name: ""))RunSaveResetPrinting the input taken using the input() function We have only taken the previous code and placed it neatly inside the print() function. When we run the code, it first takes input from our keyboard and prints whatever name we entered. This means that the input isn’t getting lost. The input() function does return the input as a text message that gets passed to the print() function to output on the screen. Try it Out This gives us great power because now our code is dynamic. We don’t have to write the name of the student inside our code’s print statement just to be able to fulfill project requirement 2. Instead of writing a separate app for Alex, Betty, Catherine, Dania, and so on, we have a code that can, in a single line, welcome anyone in a personalized way.Let’s imagine the following interaction between our app and its user, Alex: Hi Alex! Welcome to the math quiz.Alex, can you answer the following questions?.....Congratulations Alex, on scoring 5 marks!An example of an interaction between the app and the user Using our current ( print(input()) ) scheme of things, we can surely pull off the first line, but how can we print the second and the last personalized output on the screen inside one program? We don’t want to write a Python code that only works for Alex alone. And, in case we ask the user to tell us their name three times in a single session, they will not appreciate such a forgetful app. Variable assignment We now know that input() returns the user’s response from the keyboard, and instead of passing that toward the print() function, Python also lets us save the user’s response in the computer’s memory. Python lets us name that memory. The programming community calls this phenomenon a variable . We can assign a value to a variable (using = ), and finally, we can use this variable however many times in our code. For example, we can assign the value ""Alex"" to a variable user_name : user_name = ""Alex""Assigning a value to a variable Choosing the name of the variable is the programmer’s choice. Our variable names must be meaningful so that anyone reading our code can easily understand what the code intends to do.How do we know what is the value residing inside our variable? Surely, we can print the following: main.py12user_name = ""Alex""print(user_name)RunSaveResetPrinting a variable Try it Out Variables are case-sensitive in Python, i.e., it makes a difference to Python if the letters of your variables are in upper or lower case. Whatever choice we make, it is important to be consistent throughout our code wherever that variable is used. Secondly, the variable will always come on the left-hand side of the assignment operator = . The fulfilled project requirement Now, we can use our variable as many times in our code, as required by our project. Exercise Of course, we don’t want only Alex to use our app. Can you slightly change the following code so that any user in the world can write their name in the app, and for the app to print the same messages for that user as well? Your challenge is to only change the first line of code, and the rest of the code should work automatically! In this lesson, we learned how to take input in our program and even store it inside a variable so we can use it anywhere else in the program.",5763090196987904,Input and Assign to Variable
9_5924718406270976_5200140243566592,"Review of the chapter In this chapter, we have covered the following:The built-in functions in Python let us carry out useful tasks.The print() function displays data on the screen—numbers as well as text strings.The data can be saved in case-sensitive variables.The + operator lets us add numbers and join text strings. (There is an extra space after the operator.)The input() function can take input from the user’s keyboard when our code runs.With these new skills at our disposal, let’s try to determine how many requirements of the final product we can meet. Cheat sheet This cheat sheet will help us take a quick look at useful commands while we write the code for the final product. Python cheat sheet Review project requirements Let’s look at the original product requirements to determine what portions of it we can create with the skills we have acquired so far. Remember, our client had asked us to make an app for the first graders to hone their basic maths skills. The client's requirements Reduced project requirements We know how to take input for the user’s name, and their answers against questions one by one—that takes care of requirements 1 and 5. We also know how to print customized messages on the screen, so requirement 2 also gets covered. What we haven’t covered yet is generating random maths questions, but for now, we can at least print pre-defined questions on the screen and ask the user to input their answer. The completed requirements are highlighted below. The reduced requirements Let’s have a go at the project and try to meet these requirements one by one. Solutions are provided after each part. Give each part an attempt, and if you can’t figure out how to do it, you may see the solution.",5200140243566592,Project: Pythonic Attempt 1
9_5924718406270976_6326040150409216,"Back to our project So far, we have covered good ground in learning how to code for some of the project requirements. Let’s take a look at our client’s requirements once again. Project requirements that require printing on the screen According to requirements 4 and 6, our app should be able to:Perform calculations of addition, subtraction, multiplication, and divisionCompute the actual answer to each questionSo, let’s dive right in! Adding two numbers This should be easy: input two numbers and assign them to num1 and num2 , then print num1+num2 . Run the program below and see if we’re getting the expected output. main.py123456# Taking two numbers as input and storing inside two variables respectivelynum1 = input(""First number: "")num2 = input(""Second number: "")# Displaying the resultprint(""The answer to "", num1, ""+"", num2, ""is "", num1 + num2)RunSaveResetProgram to add two numbers Let’s say we enter 8 as the first number and 2 as the second number in the program above. But wait a minute! We get the output 82 instead of 10 . Why do you think that is? The data types and their conversion In our code:When we use input() , it takes whatever we type and stores it as a string . So, the numbers stored in num1 and num2 are treated as text and not as mathematical numbers.In Python, str is a basic data type used to represent text or sequences of characters (string). It is employed for storing and manipulating words, sentences, or any textual information in a program. Strings are enclosed in double quotes "" "" .When we try to add num1 and num2 using the + operator, it concatenates the two strings rather than adding the numbers. That is why we got 82 instead of 10 .To solve this problem, we need to convert these strings to numbers (to another basic data type called integer ), so the computer understands that we want to do math with them.An integer is a whole number, either positive or negative, without any decimal or fractional parts.If there was a way to convert the input strings ( str ) to integers ( int ), perhaps we could add the two numbers easily using a + . The int() function Python’s built-in function int() lets us do just that. It can take a number in string format as input, and output an integer version of it. Here’s an updated version of our code that converts the strings to integers using int() : main.py12345678910# Taking two numbers as input and storing inside two variables respectivelynum1 = input(""First number: "")num2 = input(""Second number: "")# Converting input strings to integersnum1 = int(num1)num2 = int(num2)# Displaying the resultprint(""The answer to"", num1, ""+"", num2, ""is"", num1 + num2)RunSaveResetAdding two numbers Running the code above gives us the expected result 10 . So the int() function helps us convert a string to an integer!It’s always a good idea to convert the str input from the keyboard to int in case of numbers. The str() function Conversely, we could encounter a situation where we may want to convert an integer to a string. We can do that using Python’s str() function which can take an integer as an input and output a string version of it. For example, let's look at the program below.The program Adding arithmetic operations Now that we’ve covered the concepts of basic data types, like int and str , and how to convert each data type to another, let’s get back to our project requirements. This brings us to the arithmetic operators. The arithmetic operators in Python In Python, arithmetic operators are special symbols that perform operations on variables and values, just like when solving simple arithmetic equations. For numbers, we have already seen how the + operator adds two numbers together. Other arithmetic operators available in Python are - for subtraction, * for multiplication, and / for division.Let’s look at an example of each operator in use. Now, after running the program above, you may have noticed that we’re getting the last output as a fractional value, and rightly so. Just like we have an int data type for whole numbers, we also have a basic data type for numbers with decimal values (such as 2.333) known as float .In Python, the division operation ( / ) between two integers results in a float value, even if the division should logically yield an integer. This behavior is consistent with the idea that a division operation can produce a fractional result. For example: In this case, the division 6 / 3 results in a floating-point value ( 2.0 ). When we perform division with numbers in Python, the division operation produces a float even if the result is a whole number. The .0 at the end indicates that it’s a floating-point number.Now, if we want to ensure that the result is an integer, then we can use the int() function to make sure the result is an integer: So now, the division 7 / 3 is performed, resulting in a floating-point value ( 2.3333333333333335 ). The int() function is then applied to this value. This function converts the number to an integer by truncating the decimal part. As a result, we get 2 .Now that we know we have operators available in Python, we can easily compute the correct answer to each question.In the program below, let’s take the user’s answer and then print its correct answer (calculated by our program). main.py12345678n1 = 4n2 = 9question = ""What is "" + str(n1) + ""+"" + str(n2) + ""? ""user_answer = input(question)print(""Your answer is:"", user_answer)# Computing the correct answerprint(""The correct answer is:"", n1 + n2)RunSaveResetPrinting the user’s answer and the correct answer We can do the same for all operators as below: main.py1234567891011121314151617181920212223242526n1 = 4n2 = 9question = ""What is "" + str(n1) + ""+"" + str(n2) + ""? ""user_answer = input(question)print(""Your answer is:"", user_answer)# Computing the correct answerprint(""The correct answer is:"", n1 + n2)question = ""What is "" + str(n1) + ""-"" + str(n2) + ""? ""user_answer = input(question)print(""Your answer is:"", user_answer)# Computing the correct answerprint(""The correct answer is:"", n1 - n2)question = ""What is "" + str(n1) + ""*"" + str(n2) + ""? ""user_answer = input(question)print(""Your answer is:"", user_answer)# Computing the correct answerprint(""The correct answer is:"", n1 * n2)question = ""What is "" + str(n1) + ""/"" + str(n2) + ""? ""user_answer = input(question)print(""Your answer is:"", user_answer)# Computing the correct answerprint(""The correct answer is:"", n1 / n2)RunSaveResetPrinting the user’s answer and the correct answer for different arithmetic operations Since our project is for elementary school students, let’s not expect them to compute the fractional parts of the division questions. How about we convert the actual answers to keep only the integer part of the answers?Go ahead and update the code above to change the floating point result to an integer. Show Solution That’s it! We’ve learned to incorporate requirements 4 and 6. Review of the lesson To sum up, we learned some of the built-in functions int() and str() in Python, which made it possible for us to compute correct sums. You might begin to think that Python has a built-in function for every situation in the world. However, that is not true, and it’s a good thing too.",6326040150409216,Arithmetic Operators and Data Types
9_5924718406270976_4918665266855936,"We know that built-in functions ( input() , print() , int() , etc.) are like standard ready-to-cook recipes everyone knows how to use. But did you know we can create our own functions as well? We cannot possibly have a ready-made function against every need in the world. Imagine if we wanted to create YouTube, and there was a built-in function BuildYouTubeForMe(""please"") ? It doesn’t work like that, right? Instead, Python lets us create functions of our own that we can then use as and whenever required, just like we can use built-in functions. Why Make User-Defined Functions? All in all, functions help create modular and reusable code, such as displaying a standard message, generating random numbers, or performing other predefined tasks. What are user-defined functions? Here is the basic structure of a function: def function_name(parameter1, parameter2):     # Function body    # ...    return resultA template for a user-defined function. We use the def keyword to define the function, followed by the function name and a set of parentheses. The parentheses () may contain parameters, and a colon : at the end of the line that indicates the start of the function body. The return keyword is used to specify the value that the function should return.You don’t have to be intimidated by any of it, we’ll cover all the basic keywords (like def and return ) and concepts needed to understand the user-defined functions in Python. An analogy for functions A recipe has ingredients and a set of steps. In Python, a user-defined function has parameters (like ingredients) and a set of instructions (the code inside the function). Use-case of a user-defined function Lines 1–4 contain the function definition:This is like creating the title (name of the function, order_pizza ) and a list of ingredients for your recipe ( pizza_type, extra_topping ). When we define a function, we are creating a reusable block of code with a specific purpose. This is an abstract representation of what the function does. It’s like creating a blueprint or a recipe for a certain task without actually executing it. Notice the extra spaces or indentation at the start of lines 2–4 , that’s how Python knows what part of your code is part of the order_pizza function. Line 3 is the function body:These are the steps or instructions to follow that turn the inputs ( pizza_type, extra_topping ) into the output ( pizza ). Lines 7 and 10 are the function calls made to our own function that we defined earlier:This is like using our recipe to make a specific dish. When we call a function, we provide actual values (arguments) for the parameters defined in the function. The function then executes using these specific values. Notice how we used the same function call to give us two different pizzas. This is what the reusability of code means. Creating a user-defined function Let’s define another user-defined function, add_numbers that returns the sum of num1 and num2 . Run it once to see if the function is working as expected. Making our own function The above function should run fine, we even called the function ( line 7 ). But why couldn’t we see the result? You guessed it, we haven’t printed the result yet! Show Hint Go ahead and add the print statement in the code above. Step-by-Step Construction of the Function Using user-defined functions in our project To understand how these user-defined functions help make our code more readable and clearer, let’s look at our project’s code below. A code without functions main.py1234567891011121314151617181920212223242526n1 = 6n2 = 7question = ""What is "" + str(n1) + ""+"" + str(n2) + ""? Ans: ""user_answer = input(question)print(""Your answer is:"", user_answer)# Compute the correct answerprint(""The correct answer is:"", n1 + n2)question = ""What is "" + str(n1) + ""-"" + str(n2) + ""? Ans: ""user_answer = input(question)print(""Your answer is:"", user_answer)# Compute the correct answerprint(""The correct answer is:"", n1 - n2)question = ""What is "" + str(n1) + ""*"" + str(n2) + ""? Ans: ""user_answer = input(question)print(""Your answer is:"", user_answer)# Compute the correct answerprint(""The correct answer is:"", n1 * n2)question = ""What is "" + str(n1) + ""/"" + str(n2) + ""? Ans: ""user_answer = input(question)print(""Your answer is:"", user_answer)# Compute the correct answerprint(""The correct answer is:"", int(n1 / n2))RunSaveResetCode without functions When writing lines 4 , 10 , 16 , and 22 , we are more likely to make a mistake. For example, we could miss a + character, or fail to convert the integer to a string by mistake. It’s way more convenient and safe if we make a function to create a question and use that wherever we need it.Also, note how the code lines to print the expected and the actual answers are repeating; so, they can be made into a function. Look at the code below to see what we mean by it. A code with functions Notice how the code below is now cleaner and more readable by defining two helper functions. main.py1234567891011121314151617181920212223242526272829def print_question(num1, op, num2): # Function definition to print question    print() # To add a new line for output's readability    question = ""What is "" + str(num1) + op + str(num2) + ""?""    print(question)def answer_feedback(user_ans, correct_ans): # Function definition to print answer feedback    print(""Your answer is:"", user_ans)    print(""The correct answer is:"", correct_ans) n1 = 6n2 = 7print_question(n1, ""+"", n2) #Function call with definite argumentsuser_answer = input(""Ans: "")correct_answer = n1 + n2answer_feedback(user_answer, correct_answer)print_question(n1, ""-"", n2)user_answer = input(""Ans: "")correct_answer = n1 - n2answer_feedback(user_answer, correct_answer)print_question(n1, ""*"", n2)user_answer = input(""Ans: "")correct_answer = n1 * n2answer_feedback(user_answer, correct_answer)print_question(n1, ""/"", n2)user_answer = input(""Ans: "")RunSaveResetCode with functions Note: There's a difference between defining a function in abstraction and calling the function with definite arguments. We can define a function once and call it with different arguments in various parts of our program. Review of the lesson We have seen the power of user-defined functions and how they promote modularity, reusability, and clarity in our code. However, we should always be mindful of the rules of the language and use the proper format, or else our program might result in errors.",4918665266855936,User-Defined Functions
9_5924718406270976_6044565173698560,"In this lesson, we’ll look at some of the common errors that we as programmers make and how to watch out for them. So, let’s begin! Bugs Following proper syntax and sequence is imperative while writing codes. But we all make mistakes, and it is not uncommon to run into errors while we code. The errors and flaws in code and its functionality are called bugs .The two most common types of bugs are syntax errors and logical errors . Syntax errors Syntax errors occur when the code does not conform to the syntax rules of the programming language. These errors prevent the program from running. The code below provides an example of a syntax error in our code. main.py1234567891011121314# Initialize a variable 'full_name' with an empty stringfull_name = """"# Prompt the user to enter their first name and store it in the 'first_name' variablefirst_name = input(""Enter your first name: )""# Prompt the user to enter their last name and store it in the 'last_name' variablelast_name = input(""Enter your last name: "")# Concatenate the names with a space in between and store the result in 'my_name'full_name = first_name + "" "" + last_name # The `+` symbol can be used to combine two strings.# Display a message with the user's full name using the 'full_name' variableprint(""My name is"", full_name)RunSaveResetA code example with a syntax error Note: The line number with the error in the output above is a bit misleading. Study the code line-by-line and identify the bug. If we fix the error, the code will run just fine. Logical errors These are more subtle and challenging to detect. Unlike syntax errors, a logical error won't prevent the code from executing, but the program produces unexpected results. The following example demonstrates a case of logical error in the code: 123456def calculate_rectangle_area(length, width):    area = 2*(length + width)    return areaarea_rect = calculate_rectangle_area(5, 8)print(""The area of the rectangle is: "", area_rect)RunShow SolutionSaveResetA code example with a logical error Here, we have used an incorrect formula and though is executes fine, the result is incorrect. The correct formula for the area of a rectangle is length * width .Important points to consider Here are some of the important points to consider: Indentation in Python In Python, indentation is crucial for indicating the scope of code blocks as Python uses the level of indentation to determine the structure of the code.The standard convention is to use four spaces for each level of indentation.Consistent indentation is necessary for the code to be syntactically correct and for scoping to work as intended.Try and run the code below: 123456def calculate_rectangle_area(length, width):    area = length * widthreturn arearect_area = calculate_rectangle_area(5, 8)print(""The area of the rectangle is: "", rect_area)RunShow SolutionSaveResetA code example with wrong indentation What's wrong with our code?If we look closely enough, the return statement is not indented to be part of the calculate_rectangle_area function block. Therefore, when we try to return the area variable outside the function definition, it results in an error because area is not defined outside that scope.Forgetting to indent code within a block can lead to indentation errors.Indenting inconsistently within the same block can result in unexpected behavior.Placing statements outside of the function when they should be inside can result in unexpected behavior. The correct order of statements Python executes statements sequentially within a block.The correct order of statements is vital for the algorithm (or solution) of the program, or it may also result in a logical error. main.py1234567891011# Initialize a variable 'full_name' with an empty stringfull_name = """"first_name = input(""Enter your first name: "")last_name = input(""Enter your last name: "")print(""Hi there,"", full_name)# Concatenate the names with a space in between and store the result in 'my_name'full_name = first_name + "" "" + last_name # The `+` symbol can be used to combine two strings.RunSaveResetThe greeting program with logical error The code seems to run fine, but the output is always empty. Can you figure out what is causing this bug? Changing the order of statements within the function can lead to logical errors. The order of parameters and arguments in functions Parameters are defined in the function signature.Arguments are passed to the function when calling it, matching the order of parameters. 12345def print_question(x, op, y):    print(""What is the result of "", str(x), op, str(y), ""?"")print_question(10, 2, ""*"")           RunShow SolutionSaveResetThe importance of order while passing parameters The order in which we pass arguments to a function must match the order in which the parameters are defined in the function’s definition. Python uses positional arguments, meaning the value we pass for each argument is assigned to the corresponding parameter in the order they are listed.In this function, x , op , and y are parameters, and they must be provided in that order when calling the function: print_question(10, ""*"", 2) Here, 10 corresponds to x , ""*"" corresponds to op , and 2 corresponds to y .Changing the order does not work correctly, and we might get unexpected results or errors because the values are assigned to the parameters in the order in which they are listed in the function definition.Let’s look at one more example: 123456789def calculate_sum(n1, n2, n3):    total = n1 + n2 + n3    return total# Correct order of argumentsprint(calculate_sum(3, 7, 2))# Incorrect order of arguments (will result in an error)print(calculate_sum(2, 5))  # This will raise a TypeErrorRunSaveResetSending the right number of parameters In the code above:The function calculate_sum expects three parameters ( n1 , n2 , and n3 ), as is obvious from lines 1–3 . The function call in line 6 results in the correct output. However, providing only two values ( line 9 ) or swapping their order results in a TypeError because the function expects three arguments. So, the order, as well as the number of arguments, is essential for the function to work correctly.Swapping the order of arguments can lead to logical errors.Providing more or fewer arguments than the function expects can result in a TypeError . Review of the lesson To err is human. It’s important that when we encounter errors, we take the time to understand and learn from them. This can help us avoid similar issues in the future. By being careful, we can significantly reduce the occurrence of logical and syntax errors in our code. Our client will always expect a well-tested, bug-free app.",604456517369856,Recover from Errors
9_5924718406270976_5481615220277248,"Review of chapter In this chapter, we have covered the following:Using int , str , and float data types and how to transform one type of data to another.Computing simple mathematical expressions in Python, using + , - , * , and / .Using def to define our own custom, user-defined functions to better organize our code.With these new skills at our disposal, let’s try to determine how many requirements of the final product we can meet. Cheat sheet This cheat sheet will help us have a quick look at the useful commands while we write the code for the final product.Python cheat sheet Reviewing the project requirements Let’s look at the original product requirements to determine what portions of it we can create with the skills we have acquired so far. Remember, our client had asked us to make an app for students to hone their basic maths skills.The client’s requirements What did we have by the end of the first chapter? By the end of the first chapter, we were able to take input from the user, greet the user in a customized way, and pose questions to the user. Fulfilling further requirements In this chapter, we learned about different data types and understood how to deal with numbers if they are given as input. We practiced with different operators and now know how to perform simple mathematical operations, and that takes care of requirement 6 of our project. We will also learn to generate random questions in this lesson to fulfill requirement 3. Furthermore, we now know how to contain codes in an organized way using user-defined functions. Let’s see how far these new concepts take us.",5481615220277248,Project: Pythonic Attempt 2
9_5924718406270976_6607515127119872,"Comparison and logical operators We know how to use built-in functions as well as define our own functions. We also know how to take input from the user and assign it to a variable for storage (and reuse) or pass it as further input to a function. We also know how to output something on the screen for the user. But we can only write sequential programs, where the computer fetches and executes one line of our code after another, from the first executable line to the last, in a strictly sequential order.1 of 3 This equips us with the necessary skills to solve a lot of interesting problems, but there are still some problems that sequential programs cannot solve. Sometimes, a solution might require non-sequential execution as well:1 of 3 This chapter is about learning how to write programs that can, while they are executing, be selective about executing lines of code. Secondly, we will learn to write programs that can execute some lines of our code multiple times. Our project will require us to be able to code this way. The project requirements Let’s attend to our client’s requirements for the project once again, this time focusing on the highlighted requirements for announcing the correct score to the user.The project requirements that require a comparison Imagine Alex, an elementary school student, uses our app and manages to get 3 questions right. When Betty, another student, uses our app, she gets all 5 questions right. We are not going to write two different programs—one for Alex and one for Betty. But, the same piece of code should compute that Alex’s score is 3 and Betty’s score is 5.Of course, our app cannot know in advance what the final score of its user is eventually going to be. It is going to be known to our program while the code is being executed by Alex and Betty, respectively. Note: How does the code know if the user has entered the correct answer to the question? Till now, we have seen how to compute the correct expected answer, given a question. For instance, if the question was 4 * 7 : main.py123user_answer = int(input(""What is 4 * 7? ""))correct_answer = 4 * 7RunSaveResetComputing the correct answer So we have two numbers in two appropriately named variables. How would we know if user_answer is correct? Because if we know it is correct, we need to update the user’s score by 1. Line 3 is inviting you; what can be done there right after we have correct_answer and user_answer ?Well, we know what you’re thinking. You’re thinking that it’s as simple as comparing the two numbers to see if they are equal or not!Right, we do have a symbol for equality, we have known it since childhood, but we have been using that in Python for assigning some value to a variable. We have even used that in lines 1–2 . But why not take a chance and use that for comparing two numbers as well to see if they are equal? main.py123user_answer = int(input(""What is 4 * 7? ""))correct_answer = 4 * 7user_answer = correct_answerRunSaveResetTaking a user’s answer That did not work as planned, or did it? How would we know? We need to be able to test our hypotheses. How about, if we insert a print statement before and after line 3 ? This way, we might know what user_answer = correct_answer is doing. main.py12345user_answer = int(input(""What is 4 * 7? ""))correct_answer = 4 * 7print(""User's answer: "", user_answer, ""Correct answer: "", correct_answer)user_answer = correct_answerprint(""User's answer: "", user_answer, ""Correct answer: "", correct_answer)RunSaveResetComparing the answer Enter 28 and it seems to work! But, run it again. This time give a wrong answer, let’s say 20 , and see what happens! Line 4 clearly ends up assigning the value in correct_answer to user_answer . But we wanted to use = for checking if the two numbers are equal or not. Equality, not assignment Since a single = is taken by Python for assignment purposes, what’s the next best option for an equality operator? How about double equals == ? main.py12345user_answer = int(input(""What is 4 * 7? ""))correct_answer = 4 * 7print(""User's answer: "", user_answer, ""Correct answer: "", correct_answer)user_answer == correct_answerprint(""User's answer: "", user_answer, ""Correct answer: "", correct_answer)RunSaveResetThe correct way of comparing If we try 28 , we’ll have the same output as before. If we try 20 , this time, the user_answer has not been updated! So, we do know that == did not assign the value 28 to user_answer , since the value of user_answer remained 20 even after line 4 has been executed. However, we need to encapsulate the code in line 4 within print in the hope of figuring out what == has been up to. main.py12345user_answer = int(input(""What is 4 * 7?""))correct_answer = 4 * 7print(""User's answer: "", user_answer, ""Correct answer: "", correct_answer)print(user_answer == correct_answer)print(""User's answer: "", user_answer, ""Correct answer: "", correct_answer)RunSaveResetThe output of the comparison Run it for 28 and then 20 . When executed, line 4 prints True first, then False . That is the comparison operator we wanted! A final word about == Conceptually, think of == as another built-in function that takes in two numbers and returns True or False . Other comparison operators We have seen == in its complete manifestation. There are other comparison operators as well: How do we update the user’s score? Now, we know how to compare user_answer to correct_answer for equality. We also know how to update the score by 1 ( score = score + 1 ). However, our client’s project requires our code to update the score only if the user has correctly answered the question, not otherwise. How do we do that? Let’s go to the next lesson.",6607515127119872,Comparison and Logical Operators
9_5924718406270976_4777927778500608,"Project requirements Let’s attend to our client’s requirements for the project once again, this time focusing on the requirements highlighted in green for updating the score when the user answers a maths question correctly.Project requirements that require selective execution What if We know we’ll only need == to check for the answer’s correctness. What if we had something in Python that could let us update the score, but only if the user_answer == correct_answer : 12345score = 0if user_answer == correct_answer:    score = score + 1else:    print(""Unfortunately your answer is not correct."")Updating the score on the correct answer Now, this code reads neatly. This is as easy as it looks—Python lets us use an if-else to control the flow of code execution. 1Which line number will not get executed when the value of user_answer is equal to correct_answer in the code above?A)Line 1B)Line 2C)Line 3D)Line 4E)Line 5Reset QuizQuestion 1 of 20 attemptedSubmit Answer Bringing if inside our project Let’s code to fulfill the project requirements. Let’s introduce a variable score . main.py12345score = 0user_answer = int(input(""What is 4*7? ""))correct_answer = 4 * 7print(""Your score is"", score)RunSaveResetInitializing a variable to store the score Why don’t we now bring our if code structure that we designed earlier so that the score only gets updated when the user_answer == correct_answer : main.py1234567score = 0print(""Your score is"", score)user_answer = int(input(""What is 4*7? ""))correct_answer = 4 * 7if user_answer == correct_answer:    score = score + 1print(""Your new score is: "", score) RunSaveResetUpdating the score on the correct answer Run it first for 28 , then next time run it for 20 . What’s the difference? Of course, the score will now only get updated when the correct answer is input by the user. Indentation matters Now, let’s make a minor indentation change. Let’s see what is going to change: main.py1234567score = 0print(""Your score is"", score)user_answer = int(input(""What is 4*7? ""))correct_answer = 4 * 7if user_answer == correct_answer:      score = score + 1      print(""Your new score is: "", score) RunSaveResetChanging indentation in the code The difference from the previous code is that now the print statement in line 7 only gets executed as part of the if block, not otherwise. Again, run it for 28 and 20. This gives us the ability to do multiple actions in case an if block is to be executed. The same is the case for the else block. Let’s finish the requirements Let’s write a code that does two things if the user_answer is correct, i.e., it updates the score and prints an affirmative message for the user. Or else , it does not update the score and only informs the user that their answer wasn’t correct. main.py123456789score = 0print(""Your score is"", score)user_answer = int(input(""What is 4*7? ""))correct_answer = 4 * 7if user_answer == correct_answer:      score = score + 1      print(""Due to correcly answering, your score is: "", score) else:      print(""Sadly, that is not a correct answer"")RunSaveResetProviding feedback based on the score Learn about if elif else We now know how a simple if-else structure works. However, there are situations where we might have to create a nested if-else , within another if-else . This complexity makes the code less readable eventually. Here’s a simple example to illustrate our point. We want to greet the user appropriately, given the time of the day. Within the first 12 hours of the day, we say “good morning” otherwise, we have two possibilities: a “good afternoon” if it is less than 18:00 hours, otherwise a “good evening.” The code looks like this: 12345678910# Using if-elsehour = 15 # Try assigning hour different values, e.g. 11, 16, 20if hour < 12:    greeting = ""Good morning""else:    if hour < 18:        greeting = ""Good afternoon""    else:        greeting = ""Good evening""print(greeting)RunSaveResetAn example of a nested if-else statement Python gives us a better option for what’s happening in lines 5 and 6 . It gives us a keyword elif (short for else and if). The use of elif makes the code so much more readable: 123456789# Using elifhour = 15if hour < 12:    greeting = ""Good morning""elif hour < 18:    greeting = ""Good afternoon""else:    greeting = ""Good evening""print(greeting)RunSaveResetAn example of if-elif-else Notice how we used else: at the end. This else is only executed when all the previous conditions have failed (are False ).In short, if-elif-else provides a way to create a chain of conditions where each condition is checked in sequence and the corresponding block of code associated with the first true condition is executed. Whether it’s simple if statements, if-else statements, or if-elif-else statements, we use them based on what we want to check in our program. Review of the lesson We have added another important skill to our toolkit with the help of the if-else structure. This will come in very handy in our lifelong programming careers.",4777927778500608,Programs That Can Compare
9_5924718406270976_5903827685343232,"We have found a way to break the strictly sequential flow of a program, by pushing one or however many statements within an if block. This means that our lines of code, other than those in if-else blocks, will get executed line by line, in sequence. But some lines of code will only get executed if a condition is True , otherwise, another set of lines will become a part of the execution. Sequential or selective, each line of code only gets executed once, and then our computer fetches the next one, and then the next. The while loop Wouldn’t it be great for the programmers if they could make the computer execute a block of code repeatedly while a condition is True ?Looping over the code For instance, if you are required to print 1 three times, what would be your code? 123print(1)print(1)print(1)RunSaveResetRepetitive printing with the sequential approach Let’s imagine we are being asked by our boss to print 1 ten times. Of course, we’d have to write 10 lines of code. We’ll drag our feet a little but we’ll still be willing to write those 10 lines of code. But now, our boss is ordering us to print it a 1000 times! Would we protest, resign, or start writing long and tedious code where every line is doing the same thing over and over again?Even if we are okay with calling the print() function again and again, we need to be able to keep a count of how many times we have repeated the task. Let’s use a variable and name it appropriately to keep track of it. We initialize counter with 1: counter = 1 We know there are comparison operators, such as < or less than equal to, <= that we can use to keep track of the counter. But this time, instead of checking to see if the condition is true or not, we need a mechanism to keep printing while the condition is true: counter = 1while counter <= 10:    print(1)A loop to execute statement multiple times Thankfully, Python gives us this new keyword while . This makes our code so neat. Let’s impress the boss: 3 lines of code is much more efficient than other programmers who are still writing their 10 lines. 123counter = 1while counter <= 10:    print(1)RunAI MentorSaveResetTry running the loop Oh no! This keeps printing until the Python program has had enough!Why don’t you seek the help of Educative’s AI mentor? Don't hesitate to press the new button!Looks like we forgot to update the counter, in the absence of which the value of the counter remains <= 10 forever. This was our mistake, not the computer’s. Let’s fix that.There, this might work now. 1234counter = 1while counter <= 10:    print(1)counter = counter + 1RunAI MentorSaveResetTrying to stop the loop Oh no! That didn’t work either! Should we give up? No, we think, we always think, instead of giving up. We always think of why things don’t work the way we expect them to. We do this persistently, like being in a loop, till we succeed.What is the difference between the two pieces of code here? Code ACode BWe’ve already tried code A, and it kept printing 1 forever. Why does code B work, we’ve only made a tiny change in the last line, and that too, only in the last statement’s indentation. Run code B first, but then think about why it stopped after printing the 10th 1 . 1234counter = 1while counter <= 10:    print(1)    counter = counter + 1RunSaveResetThe correct way to stop the loop Printing the counter Instead of print(1) , let’s print(counter) to know how code A and code B keep track of the counter. Remember, our algorithmic idea was to initialize a counter to 1 , and right after printing the number, increase the counter by 1 so that the while loop only works 10 times. 1234counter = 1while counter <= 10:    print(counter)    counter = counter + 1RunAI MentorSaveResetMaking a counter Life without while() Do you see what our computer is doing for us? If we unroll this efficient loop-based program, this is what we did. 123456789101112131415161718192021counter = 1print(counter)counter = counter + 1print(counter)counter = counter + 1print(counter)counter = counter + 1print(counter)counter = counter + 1print(counter)counter = counter + 1print(counter)counter = counter + 1print(counter)counter = counter + 1print(counter)counter = counter + 1print(counter)counter = counter + 1print(counter)counter = counter + 1RunSaveResetSequential codes can become cumbersome Imagine writing the above code manually when the boss asked us to print 100 numbers. Well, now we don’t have to resign because we know that whenever there is a repeating pattern in our code or whenever something needs to be done again and again, we can use a while loop. Challenge Can you prove to your boss that you can write a program that prints 1000 numbers on the screen? And that you can do that in just a few seconds? 1234counter = 1while counter <= 10:    print(counter)    counter = counter + 1RunAI MentorSaveResetTry running a longer loop Show Hint The while loop in our projectQWhat are some of the repeating patterns in your client’s project where a loop can be applied?A)Asking the user for their name.B)Printing the user’s final scoreC)Posing a question, taking the user’s answer, checking if the learner’s answer is correct, and updating the score.Reset QuizSubmit Answer",5903827685343232,Programs That Can Loop
9_5924718406270976_5340877731921920,"Review of the chapter In this chapter, we covered the following:The comparison operators can be used to compare values (compare user_answer to correct_answer for equality, in our case). The need for if , elif , and else to perform an action only when certain condition(s) are met.The convenience that the while loops bring when performing repetitive tasks. Cheat sheetPython cheat sheet Reviewing the project requirements Once again, let’s look at the original product requirements, this time to appreciate how far we’ve come!Client’s requirements The remaining project requirements We’ve covered most of the project requirements. We’re left with just three remaining requirements, as highlighted in green below:The project requirements that require printing on the screen Now, let’s fulfill these requirements one by one. Solutions are provided after each part. Give each part an attempt, and if you feel stuck, you may see the solution.",534087773192192,Python Project: Completed
9_5924718406270976_6466777638764544,"Conclusion This course has taught you how to code in Python, starting from scratch. It has tried to cement a solid conceptual foundation for procedural programming in Python. Furthermore, it gradually built every concept on top of that foundation, starting from built-in functions to user-defined functions and various program structures. By the end of this first programming journey, you have a holistic, integrated concept map of what it means to be able to code in Python.In addition, the course kept every new concept grounded by integrating them into the calculator-based Python app, which kept on building in every chapter. You can proudly boast about this in your developer profile.Thank you for being a part of the Educative learning community. This is only the start of your lifelong learning in the world of programming and Python. There are so many courses and projects to take from here onward.We look forward to your feedback, comments, concerns, and questions. Feel free to contribute to the codebase or drop us an email!",6466777638764544,Wrap Up